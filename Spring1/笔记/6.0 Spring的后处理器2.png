Spring的后处理器是Spring对外开发的重要扩展点，允许我们介入到Bean的整个实例化流程中来，以达到动态注册
BeanDefinition，动态修改BeanDefinition，以及动态修改Bean的作用。Spring主要有两种后处理器:
BeanFactoryPostProcessor:Bean工厂后处理器，在BeanDefinitionMap填充完毕，Bean实例化之前执行
BeanPostProcessor:Bean后处理器，一般在Bean实例化之后，填充到单例池singletonObjects之前执行。

BeanFactoryPostProcessor是一个接口规范，实现了该接口的类只要交由Spring容器管理的话，那么Spring就会回
调该接口的方法，用于对BeanDefinition注册和修改的功能。
BeanFactoryPostProcessor定义如下:
public interface BeanFactoryPostProcessor
void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory);

Spring 提供了一个BeanFactoryPostProcessor的子接囗BeanDefinitionRegistryPostProcessor专门用于注册
BeanDefinition操作
public class MyBeanFactoryPostProcessor2
implements BeanDefinitionRegistryPostProcessor
@Override
public void postProcessBeanFactory(ConfigurableListableBeanFactory
configurableListableBeanFactory)throws BeansException{}
@Override
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry)
throws BeansException{
BeanDefinition beanDefinition = new RootBeanDefinition();
beanDefinition.setBeanClassName("com.clover.dao.userDaoImpl2");
beanDefinitionRegistry.registerBeanDefinition("userDao2",beanDefinition);

Bean后处理器-BeanPostProcessor
Bean被实例化后，到最终缓存到名为singletonObjects单例池之前，中间会经过Bean的初始化过程，例如:属性的
填充、初始方法init的执行等，其中有一个对外进行扩展的点BeanPostProcessor，我们称为Bean后处理。跟上面的
Bean工厂后处理器相似，它也是一个接口，实现了该接口并被容器管理的BeanPostProcessor，会在流程节点上被
Spring自动调用。

Bean后处理器-BeanPostProcessor
BeanPostProcessor的接定义如下:
public interface BeanPostProcessor
@Nullable
//在属性注入完毕，init初始化方法执行之前被回调
default Object postProcessBeforeInitialization(Object bean, String beanName) throws
BeansException{
return bean;
}
@Nullable
//在初始化方法执行之后，被添加到单例池singletonobjects之前被回调
default Object postProcessAfterInitialization(Object bean, String beanName) throws
BeansException{
return bean;
}

填充完毕后回调
workDao IMP
userDao:post before initialization
afterPropertiesSet
workDao init
userDao:post after initialization
com.clover.dao.imp.WorkDaoImp@2145433b

Bean后处理器-BeanPostProcessor
编写BeanPostProcessor，增强逻辑编写在 after方法中
public Object postProcessAfterInitialization(Object bean, String beanName) throws
BeansException
//对Bean进行动态代理，返回的是Proxy代理对象
Obiect proxyBean = Proxy.newProxyInstance(bean.getClass().getClassLoader (),
bean.getClass().qetInterfaces()
(0bject proxy,Method method,Object[largs)->{
long start
=System.currentTimeMillis();
System.out.println("开始时间:"+new Date(start));
//执行目标方法
Object result=method.invoke(bean，args);
long end =System.currentTimeMillis();
System.out.println("结束时间:"+new Date(end));
return result;
}):
//返回代理对象
return proxyBean;
}

