Spring Bean的生命周期
Spring Bean的生命周期是从 Bean 实例化之后，即通过反射创建出对象之后，到Bean成为一个完整对象，最终存储
到单例池中，这个过程被称为Spring Bean的生命周期。Spring Bean的生命周期大体上分为三个阶段:
Bean的实例化阶段:Spring框架会取出BeanDefinition的信息进行判断当前Bean的范围是否是singleton的
是否不是延迟加载的，是否不是FactoryBean等，最终将一个普通的singleton的Bean通过反射进行实例化;
Bean的初始化阶段:Bean创建之后还仅仅是个"半成品"，还需要对Bean实例的属性进行填充、执行一些Aware
接口方法、执行BeanPostProcessor方法、执行InitializingBean接口的初始化方法、执行自定义初始化init方法
等。该阶段是Spring最具技术含量和复杂度的阶段，Aop增强功能，后面要学习的Spring的注解功能等
spring高频面试题Bean的循环引用问题都是在这个阶段体现的;
Bean的完成阶段:经过初始化阶段，Bean就成为了一个完整的Spring Bean，被存储到单例池
singletonObjects中去了，即完成了Spring Bean的整个生命周期。

由于Bean的初始化阶段的步骤比较复杂，所以着重研究Bean的初始化阶段
Spring Bean的初始化过程涉及如下几个过程:
Bean实例的属性填充
Aware接口属性注入
BeanPostProcessor的before()方法回调
InitializingBean接口的初始化方法回调
自定义初始化方法init回调
BeanPostProcessor的after()方法回调
PS:通过代码验证上述初始化顺序。

Bean实例属性填充
BeanDefinition 中有对当前Bean实体的注入信息通过属性propertyValues进行了存储，例如UserService的属性信息。

Bean实例属性填充
Spring在进行属性注入时，会分为如下几种情况:
注入普通属性，String、int或存储基本类型的集合时，直接通过set方法的反射设置进去;
注入单向对象引用属性时，从容器中getBean获取后通过set方法反射设置进去，如果容器中没有，则先创建被
注入对象Bean实例(完成整个生命周期)后，在进行注入操作;
注入双向对象引用属性时，就比较复杂了，涉及了循环引用(循环依赖)问题，下面会详细述解决方案。
PS:通过代码验证上述第二第三种属性填充……

Bean实例属性填充
UserService和UserDao循环依赖的过程结合上述三级缓存描述一下
UserService 实例化对象，但尚未初始化，将UserService存储到三级缓存;
UserService 属性注入，需要UserDao，从缓存中获取，没有UserDao;
UserDao实例化对象，但尚未初始化，将UserDao存储到到三级缓存;
UserDao属性注入，需要UserService，从三级缓存获取UserService，UserService从三级缓存移入二级缓存;
UserDao执行其他生命周期过程，最终成为一个完成Bean，存储到一级缓存，删除二三级缓存;
UserService注入UserDao;
UserService执行其他生命周期过程，最终成为一个完成Bean，存储到一级缓存，删除二三级缓存。

常用的Aware接口
Aware接口是一种框架辅助属性注入的一种思想，其他框架中也可以看到类似的接口。框架具备高度封装性，我们接
触到的一般都是业务代码，一个底层功能AP!不能轻易的获取到，但是这不意味着永远用不到这些对象，如果用到了
就可以使用框架提供的类似Aware的接口，让框架给我们注入该对象。
Aware接口
ServletContextAware
BeanFactoryAware
BeanNameAware
ApplicationContextAware
回调方法
setServletContext(ServetContext context)
setBeanFactory(BeanFactory factory)
setBeanName(String beanName)
setApplicationContext(ApplicationContext applicationContext)
作用
Spring框架回调方法注入ServletContext对象
web环境下才生效
Spring框架回调方法注入beanFactory对象
Spring框架回调方法注入当前Bean在容器中
的beanName
Spring框架回调方法注入applicationContext
对象